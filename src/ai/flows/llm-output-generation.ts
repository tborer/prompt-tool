// src/ai/flows/llm-output-generation.ts
'use server';

/**
 * @fileOverview Flow to generate output from the LLM based on selected prompt and user inputs.
 *
 * - generateLlmOutput - A function that handles the generation of output from the LLM.
 * - GenerateLlmOutputInput - The input type for the generateLlmOutput function.
 * - GenerateLlmOutputOutput - The return type for the generateLlmOutput function.
 */

import {ai} from '@/lib/genkit';
import {z} from 'genkit';

const GenerateLlmOutputInputSchema = z.object({
  promptType: z.enum(['Prompt 1', 'Prompt 2']).describe('The type of prompt to use.'),
  field1: z.string().optional().describe('Field 1 input.'),
  field2: z.string().optional().describe('Field 2 input.'),
  field3: z.string().optional().describe('Field 3 input.'),
  field4: z.string().optional().describe('Field 4 input.'),
  field5: z.string().optional().describe('Field 5 input.'),
  field6: z.string().optional().describe('Field 6 input.'),
  prompt1Setup: z.string().describe('Prompt 1 setup text.'),
  prompt2Setup: z.string().describe('Prompt 2 setup text.'),
  llmApiKey: z.string().describe('The LLM API key.'),
});

export type GenerateLlmOutputInput = z.infer<typeof GenerateLlmOutputInputSchema>;

const GenerateLlmOutputOutputSchema = z.object({
  output: z.string().describe('The output generated by the LLM.'),
});

export type GenerateLlmOutputOutput = z.infer<typeof GenerateLlmOutputOutputSchema>;

export async function generateLlmOutput(input: GenerateLlmOutputInput): Promise<GenerateLlmOutputOutput> {
  return generateLlmOutputFlow(input);
}

const prompt = ai.definePrompt({
  name: 'llmOutputPrompt',
  input: {schema: GenerateLlmOutputInputSchema},
  output: {schema: GenerateLlmOutputOutputSchema},
  prompt: `{{#ifEquals promptType "Prompt 1"}}
    {{{prompt1Setup}}}
  {{else}}
    {{{prompt2Setup}}}
  {{/ifEquals}}
  `,
  config: {
    model: 'googleai/gemini-2.0-flash'
  }
});

const generateLlmOutputFlow = ai.defineFlow(
  {
    name: 'generateLlmOutputFlow',
    inputSchema: GenerateLlmOutputInputSchema,
    outputSchema: GenerateLlmOutputOutputSchema,
  },
  async input => {
    if (input.promptType === 'Prompt 1' && !input.prompt1Setup) {
      throw new Error('Prompt 1 Setup is required.');
    }

    if (input.promptType === 'Prompt 2' && !input.prompt2Setup) {
      throw new Error('Prompt 2 Setup is required.');
    }

    if (input.promptType === 'Prompt 1' && (!input.field1 || !input.field2 || !input.field3)) {
      // Don't throw error here, because the fields are optional
    }

     if (input.promptType === 'Prompt 2' && (!input.field4 || !input.field5 || !input.field6)) {
      // Don't throw error here, because the fields are optional
    }

    const {
      field1,
      field2,
      field3,
      field4,
      field5,
      field6,
      prompt1Setup,
      prompt2Setup,
      promptType
    } = input

 try {
      const processedPrompt1Setup = replaceVariables(prompt1Setup, {field1, field2, field3});
      const processedPrompt2Setup = replaceVariables(prompt2Setup, {field4, field5, field6});

 console.log('Input data used in prompt:', {
        ...input,
        prompt1Setup: processedPrompt1Setup,
        prompt2Setup: processedPrompt2Setup,
      });

      // Log the actual prompt sent to the LLM after variable replacement
      console.log('Actual prompt sent to LLM:', {
        prompt: input.promptType === 'Prompt 1' ? processedPrompt1Setup : processedPrompt2Setup,
      });
 const { output } = await prompt({
        ...input,
        prompt1Setup: processedPrompt1Setup,
        prompt2Setup: processedPrompt2Setup,
      });
 console.log('Output received from LLM:', output);

 return { output: output!.output };
    } catch (error) {
      console.error('Error generating LLM output:', error);
 throw error; // Re-throw the error after logging
    }
  }
);

function replaceVariables(template: string, data: Record<string, string | undefined>): string {
  let result = template;
  for (const key in data) {
    if (data.hasOwnProperty(key)) {
      const value = data[key] || ''; // Use an empty string if the value is undefined
      const regex = new RegExp(`\{${key}\}`, 'g');
      result = result.replace(regex, value);
    }
  }
  return result;
}
